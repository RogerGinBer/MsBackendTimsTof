% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MsBackendTimsTof-functions.R,
%   R/MsBackendTimsTof.R
\docType{class}
\name{MsBackendTimsTof}
\alias{MsBackendTimsTof}
\alias{MsBackendTimsTof-class}
\alias{backendInitialize,MsBackendTimsTof-method}
\alias{length,MsBackendTimsTof-method}
\alias{peaksData,MsBackendTimsTof-method}
\alias{peaksVariables,MsBackendTimsTof-method}
\alias{mz,MsBackendTimsTof-method}
\alias{intensity,MsBackendTimsTof-method}
\alias{rtime,MsBackendTimsTof-method}
\alias{[,MsBackendTimsTof-method}
\alias{dataStorage,MsBackendTimsTof-method}
\alias{spectraData,MsBackendTimsTof-method}
\alias{show,MsBackendTimsTof-method}
\alias{msLevel,MsBackendTimsTof-method}
\alias{precursorMz,MsBackendTimsTof-method}
\alias{precursorCharge,MsBackendTimsTof-method}
\alias{precursorIntensity,MsBackendTimsTof-method}
\alias{collisionEnergy,MsBackendTimsTof-method}
\alias{isolationWindowLowerMz,MsBackendTimsTof-method}
\alias{isolationWindowTargetMz,MsBackendTimsTof-method}
\alias{isolationWindowUpperMz,MsBackendTimsTof-method}
\alias{$,MsBackendTimsTof-method}
\alias{spectraVariables,MsBackendTimsTof-method}
\alias{selectSpectraVariables,MsBackendTimsTof-method}
\alias{$<-,MsBackendTimsTof-method}
\alias{precScanNum,MsBackendTimsTof-method}
\alias{spectraNames,MsBackendTimsTof-method}
\alias{tic,MsBackendTimsTof-method}
\title{TimsTOF data backend}
\usage{
MsBackendTimsTof()

\S4method{backendInitialize}{MsBackendTimsTof}(object, files, ..., BPPARAM = bpparam())

\S4method{length}{MsBackendTimsTof}(x)

\S4method{peaksData}{MsBackendTimsTof}(object, columns = c("mz", "intensity"))

\S4method{peaksVariables}{MsBackendTimsTof}(object)

\S4method{mz}{MsBackendTimsTof}(object)

\S4method{intensity}{MsBackendTimsTof}(object)

\S4method{rtime}{MsBackendTimsTof}(object)

\S4method{[}{MsBackendTimsTof}(x, i, j, ..., drop = FALSE)

\S4method{dataStorage}{MsBackendTimsTof}(object)

\S4method{spectraData}{MsBackendTimsTof}(object, columns = spectraVariables(object))

\S4method{show}{MsBackendTimsTof}(object)

\S4method{msLevel}{MsBackendTimsTof}(object, ...)

\S4method{precursorMz}{MsBackendTimsTof}(object, ...)

\S4method{precursorCharge}{MsBackendTimsTof}(object, ...)

\S4method{precursorIntensity}{MsBackendTimsTof}(object, ...)

\S4method{collisionEnergy}{MsBackendTimsTof}(object, ...)

\S4method{isolationWindowLowerMz}{MsBackendTimsTof}(object, ...)

\S4method{isolationWindowTargetMz}{MsBackendTimsTof}(object, ...)

\S4method{isolationWindowUpperMz}{MsBackendTimsTof}(object, ...)

\S4method{$}{MsBackendTimsTof}(x, name)

\S4method{spectraVariables}{MsBackendTimsTof}(object, ...)

\S4method{selectSpectraVariables}{MsBackendTimsTof}(object, spectraVariables = spectraVariables(object))

\S4method{$}{MsBackendTimsTof}(x, name) <- value

\S4method{precScanNum}{MsBackendTimsTof}(object)

\S4method{spectraNames}{MsBackendTimsTof}(object)

\S4method{tic}{MsBackendTimsTof}(object, initial = TRUE)
}
\arguments{
\item{object}{\code{MsBackendTimsTof} object.}

\item{files}{\code{character} specifying TimsTOF ’*.d’ folders names.}

\item{...}{Additional arguments.}

\item{BPPARAM}{Parameter object defining the parallel processing
setup to import data in parallel. Defaults to \code{BPPARAM = bpparam()}.
See \code{\link[=bpparam]{bpparam()}} for more information.}

\item{x}{\code{MsBackendTimsTof} object.}

\item{columns}{For \code{spectraData}: names of the spectra variables to extract
from \code{object}. For \code{peaksData}: names of the peak variables to extract.
Defaults to \code{columns = c("mz", "intensity")}.}

\item{i}{For \code{[}: \code{integer}, \code{logical} to subset the object.}

\item{j}{For \code{[}: not supported.}

\item{drop}{For \code{[}: not considered.}

\item{name}{For \code{$}: the name of the variable to access.}

\item{spectraVariables}{\code{character} with the names of the spectra variables
that should be retained in the returned object.}

\item{value}{For \verb{$<-}: the value to assign to the spectra variable.}

\item{initial}{For \code{tic}: \code{logical(1)} whether the original total ion count
should be returned (\code{initial = TRUE}, the default) or whether it
should be calculated on the spectras' intensities (\code{initial = FALSE}).}
}
\description{
The \code{MsBackendTimsTof} class supports Bruker TimsTOF data files. New objects
are created with the \code{MsBackendTimsTof} function. To ensure a small memory
footprint, only general information is kept in memory (such as number of
frames and scans) and all data (specifically the peaks data) is retrieved
from the original file on-the-fly. By extending the \code{\link[=MsBackendCached]{MsBackendCached()}}
backend from the \code{Spectra} package, adding or (locally) changing spectra
values is also supported.
}
\section{Available methods}{


The following methods are implemented:
\itemize{
\item \code{$}: access any of the \code{spectraVariables} of the backend.
\item \verb{$<-}: add a new spectra variable or change values for an existing spectra
variables. Values can be changed for any spectra variable except \emph{peaks
variables} (\code{\link[=peaksVariables]{peaksVariables()}}) or special internal variables \code{"file"} and
\code{"frameId"}. Note that changes to spectra variables are only cached within
the object but not propagated to the original data files.
\item \code{[}: subset the backend. Only subsetting by element (\emph{row}/\code{i}) is
allowed. First the \verb{@indices} slot of \code{object} is subsetted and then the
\code{frames} and \code{fileNames} slots are subsetted accordingly. Note that \code{[}
does not update the values of \code{frames} variables (such as \code{"MaxIntensity"},
\code{"SummedIntensities"}, \code{"NumScans"} and \code{"NumPeaks"}).
\item \code{backendInitialize}: initializes \code{object} (the \code{MsBackendTimsTof} object)
using TimsTOF data files whose path is specified by \code{files}. This method
is supposed to be called right after creating a \code{MsBackendTimsTof} object
with \code{MsBackendTimsTof} function.
\item \code{dataStorage}: gets a \code{character} of length equal to the number of spectra
in \code{object} with the names of the '*.d' folders where each spectrum is
stored.
\item \code{intensity}: gets the intensity values from the spectra in the backend.
Returns a \code{\link[=NumericList]{NumericList()}} of \code{numeric} vectors (intensity values for each
spectrum). The length of the list is equal to the number of
spectra in \code{object}.
\item \code{msLevel}: gets the spectra MS level. Returns an integer vector (of length
equal to the number of spectra) with the MS level for each spectrum.
\item \code{mz}: gets the mass-to-charge ratios (m/z) from the spectra in the backend.
Returns a \code{\link[=NumericList]{NumericList()}} of \code{numeric} vectors (m/z values for each
spectrum). The length of the list is equal to the number of spectra in
\code{object}.
\item \code{peaksData}: gets the peak matrices of the spectra in the backend.
Returns a \code{list} of \code{matrix} with columns defined by parameter \code{columns}
(which defaults to \code{columns = c("mz", "intensity")}. Use \code{peaksVariables}
to list all supported and available columns for a backend.
The length of the \code{list} is equal to the number of spectra in \code{object}.
\item \code{peaksVariables}: gets the supported peak variables (columns) for the
backend.
\item \code{rtime}: gets the retention times for each spectrum. Returns a \code{numeric}
vector (length equal to the number of spectra) with the retention time
for each spectrum.
\item \code{selectSpectraVariables}: reduces the available spectra variables to the
ones specified with parameter \code{spectraVariables}. For \emph{core spectra
variables} (\code{\link[=coreSpectraVariables]{coreSpectraVariables()}}) only their values will be removed,
but not the variable itself.
\item \code{spectraData}: gets spectra variables (specified by \code{columns}) from
\code{object}.
\item \code{spectraNames}: returns an \emph{ID}/name for each spectrum. As IDs the index
of the spectrum within the object after the initialization is used. This
index/spectra name is unique and stable for each spectrum within the same
object.
\item \code{spectraVariables}: returns a \code{character} vector with the spectra variables
names of core spectra variables defined in the Spectra package and other
additional variables contained in \code{object}. Note that also \code{"mz"} and
\code{"intensity"} (which are by default not returned by the
\verb{spectraVariables,Spectra} method) are returned.
\item \code{tic}: calculates the total ion count from the intensities of each
spectrum (for \code{initial = FALSE}). For \code{initial = TRUE} \code{NA} is returned
for all spectra.
}
}

\examples{

## Load the opentimsr package to retrieve the required shared library
## from Bruker.
so_folder <- tempdir()
library(opentimsr)
so_file <- download_bruker_proprietary_code(so_folder, method = "wget")
setup_bruker_so(so_file)
path_d_folder <- system.file("ddaPASEF.d",
                             package = "MsBackendTimsTof")

## Define the test file
fl <- system.file("ddaPASEF.d", package = "MsBackendTimsTof")

## Create a MsBackend instance for that file
be <- backendInitialize(MsBackendTimsTof(), fl)
be

## Available spectra variables
spectraVariables(be)

## Subset to 10 randomly selected spectra.
be_sub <- be[sort(sample(seq_along(be), 10))]
rtime(be_sub)

pd <- peaksData(be_sub, columns = c("mz", "intensity", "tof", "inv_ion_mobility"))

## Add a new spectra variable
be$new_var <- seq_along(be)

head(be$new_var)

## Changing values of a spectra variable. Note that these are only changed
## *locally* within the object, but not in the original data files.
head(rtime(be))
be$rtime <- rtime(be) + 10
head(rtime(be))
}
\author{
Andrea Vicini, Johannes Rainer
}
